{
  "language": "Solidity",
  "sources": {
    "contracts/incognito_proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./pause.sol\";\n\n/**\n * @dev Stores beacon and bridge committee members of Incognito Chain. Other\n * contracts can query this contract to check if an instruction is confimed on\n * Incognito\n */\ncontract IncognitoProxy is AdminPausable {\n    struct Committee {\n        address[] pubkeys; // ETH address of all members\n        uint startBlock; // The block that the committee starts to work on\n    }\n\n    Committee[] public beaconCommittees; // All beacon committees from genesis block\n    Committee[] public bridgeCommittees; // All bridge committees from genesis block\n\n    event BeaconCommitteeSwapped(uint id, uint startHeight);\n    event BridgeCommitteeSwapped(uint id, uint startHeight);\n\n    // error code\n    enum Errors {\n        SIGNATURE_DIMENSION_MISMATCH,\n        INSTRUCTION_NOT_APPROVED,\n        INSTRUCTION_INVALID,\n        COMMITTEE_HEIGHT_MISMATCH,\n        PREV_COMMITTEE_HEIGHT_MISMATCH,\n        SIGNATURE_INVALID,\n        MERKLE_PROOF_INVALID,\n        UNEXPECTED_ERROR\n    }\n\n    /**\n     * @dev Sets the genesis committees and the address of admin\n     * @notice Admin is the one responsible for the contract in case of emergency\n     * Here, they are authorized to Pause the contract, stopping new committees\n     * from being added to the contract\n     * Admin is authorized to Pause the contract at anytime for 1 year starting\n     * from the moment the contract is deployed\n     * Admin is also authorized to increase the expiration time if they need more\n     * time to implement a more decentralized failsafe mechanism\n     * @notice Admin can also be a smart contract implementing a DAO and making decisions through a voting system\n     * @param admin: ETH address\n     * @param beaconCommittee: genesis committee members of beacon chain\n     * @param bridgeCommittee: genesis committee members of bridge\n     */\n    constructor(\n        address admin,\n        address[] memory beaconCommittee,\n        address[] memory bridgeCommittee\n    ) public AdminPausable(admin) {\n        beaconCommittees.push(Committee({\n            pubkeys: beaconCommittee,\n            startBlock: 0\n        }));\n\n        bridgeCommittees.push(Committee({\n            pubkeys: bridgeCommittee,\n            startBlock: 0\n        }));\n    }\n\n    /**\n     * @dev Gets a beacon committee in the past\n     * @notice We need to implement this because the autogenerated getter returns only the startBlock\n     * @param i index of the committee to get\n     * @return the committee and their startBlock\n     */\n    function getBeaconCommittee(uint i) public view returns(Committee memory) {\n        return beaconCommittees[i];\n    }\n\n    /**\n     * @dev Gets a bridge committee in the past\n     * @notice the same as getBeaconCommittee but for bridge\n     */\n    function getBridgeCommittee(uint i) public view returns(Committee memory) {\n        return bridgeCommittees[i];\n    }\n\n    /**\n     * @dev Updates the latest committee of the bridge\n     * @notice This function takes a swap instruction on Incognito Chain, checks for its validity and stores the latest committee\n     * @notice This only works when the contract is not Paused\n     * @notice All params except inst are the list of 2 elements corresponding to the proof on beacon and bridge\n     * @param inst: the decoded instruction as a list of bytes\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function swapBridgeCommittee(\n        bytes memory inst,\n        bytes32[][2] memory instPaths,\n        bool[][2] memory instPathIsLefts,\n        bytes32[2] memory instRoots,\n        bytes32[2] memory blkData,\n        uint[][2] memory sigIdxs,\n        uint8[][2] memory sigVs,\n        bytes32[][2] memory sigRs,\n        bytes32[][2] memory sigSs\n    ) public isNotPaused {\n        bytes32 instHash = keccak256(inst);\n\n        // Verify instruction on beacon\n        require(instructionApproved(\n            true,\n            instHash,\n            beaconCommittees[beaconCommittees.length-1].startBlock,\n            instPaths[0],\n            instPathIsLefts[0],\n            instRoots[0],\n            blkData[0],\n            sigIdxs[0],\n            sigVs[0],\n            sigRs[0],\n            sigSs[0]\n        ), errorToString(Errors.INSTRUCTION_NOT_APPROVED));\n\n        // Verify instruction on bridge\n        require(instructionApproved(\n            false,\n            instHash,\n            bridgeCommittees[bridgeCommittees.length-1].startBlock,\n            instPaths[1],\n            instPathIsLefts[1],\n            instRoots[1],\n            blkData[1],\n            sigIdxs[1],\n            sigVs[1],\n            sigRs[1],\n            sigSs[1]\n        ), errorToString(Errors.INSTRUCTION_NOT_APPROVED));\n\n        // Parse instruction and check metadata\n        (uint prevCommitteeStartHeight, uint startHeight) = extractMetaFromInstruction(inst, 71, 1);\n        // require(meta == 71 && shard == 1, errorToString(Errors.INSTRUCTION_INVALID));\n\n        uint myLatestCommitteeHeight = bridgeCommittees[bridgeCommittees.length-1].startBlock;\n        // Make sure 1 instruction can't be used twice (using startHeight)\n        require(prevCommitteeStartHeight == myLatestCommitteeHeight, errorToString(Errors.PREV_COMMITTEE_HEIGHT_MISMATCH));\n        require(startHeight > myLatestCommitteeHeight, errorToString(Errors.COMMITTEE_HEIGHT_MISMATCH));\n\n        // Swap committee\n        address[] memory pubkeys = extractCommitteeFromInstruction(inst);\n        bridgeCommittees.push(Committee({\n            pubkeys: pubkeys,\n            startBlock: startHeight\n        }));\n\n        emit BridgeCommitteeSwapped(bridgeCommittees.length, startHeight);\n    }\n\n    /**\n     * @dev Updates the latest committee of the beacon chain\n     * @notice This function takes a swap instruction on Incognito Chain, checks for its validity and stores the latest committee\n     * @notice This only works when the contract is not Paused\n     * @notice Swapping beacon committee doesn't require that the instruction is included in the bridge chain\n     * @notice All params are the same as swapBridgeCommittee\n     */\n    function swapBeaconCommittee(\n        bytes memory inst,\n        bytes32[] memory instPath,\n        bool[] memory instPathIsLeft,\n        bytes32 instRoot,\n        bytes32 blkData,\n        uint[] memory sigIdx,\n        uint8[] memory sigV,\n        bytes32[] memory sigR,\n        bytes32[] memory sigS\n    ) public isNotPaused {\n        bytes32 instHash = keccak256(inst);\n\n        // Verify instruction on beacon\n        require(instructionApproved(\n            true,\n            instHash,\n            beaconCommittees[beaconCommittees.length-1].startBlock,\n            instPath,\n            instPathIsLeft,\n            instRoot,\n            blkData,\n            sigIdx,\n            sigV,\n            sigR,\n            sigS\n        ), errorToString(Errors.INSTRUCTION_NOT_APPROVED));\n\n        // Parse instruction and check metadata and shardID\n        (uint prevCommitteeStartHeight, uint startHeight) = extractMetaFromInstruction(inst, 70, 1);\n        // require(meta == 70 && shard == 1 && numVals > 0, errorToString(Errors.INSTRUCTION_INVALID));\n\n        uint myLatestCommitteeHeight = beaconCommittees[beaconCommittees.length-1].startBlock;\n        // Make sure 1 instruction can't be used twice (using startHeight)\n        require(prevCommitteeStartHeight == myLatestCommitteeHeight, errorToString(Errors.PREV_COMMITTEE_HEIGHT_MISMATCH));\n        require(startHeight > myLatestCommitteeHeight, errorToString(Errors.COMMITTEE_HEIGHT_MISMATCH));\n\n        // Swap committee\n        address[] memory pubkeys = extractCommitteeFromInstruction(inst);\n        beaconCommittees.push(Committee({\n            pubkeys: pubkeys,\n            startBlock: startHeight\n        }));\n\n        emit BeaconCommitteeSwapped(beaconCommittees.length, startHeight);\n    }\n\n    /**\n     * @dev Checks if an instruction is confirmed on chain (beacon or bridge)\n     * @notice A confirmation means that the instruction is included in a block\n     * that has enough validators' signatures\n     * @param isBeacon: check on beacon or bridge\n     * @param instHash: keccak256 hash of the instruction's content\n     * @param blkHeight: height of the block containing the instruction\n     * @param instPath: merkle path of the instruction\n     * @param instPathIsLeft: whether each node on the path is the left or right child\n     * @param instRoot: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdx: indices of the validators who signed this block\n     * @param sigV: part of the signatures of the validators\n     * @param sigR: part of the signatures of the validators\n     * @param sigS: part of the signatures of the validators\n     * @return bool: whether the instruction is valid and confirmed\n     */\n    function instructionApproved(\n        bool isBeacon,\n        bytes32 instHash,\n        uint blkHeight,\n        bytes32[] memory instPath,\n        bool[] memory instPathIsLeft,\n        bytes32 instRoot,\n        bytes32 blkData,\n        uint[] memory sigIdx,\n        uint8[] memory sigV,\n        bytes32[] memory sigR,\n        bytes32[] memory sigS\n    ) public view returns (bool) {\n        // Find committee in charge of this block\n        address[] memory signers;\n        uint _;\n        if (isBeacon) {\n            (signers, _) = findBeaconCommitteeFromHeight(blkHeight);\n        } else {\n            (signers, _) = findBridgeCommitteeFromHeight(blkHeight);\n        }\n\n        // Extract signers that signed this block (require sigIdx to be strictly increasing)\n        require(sigV.length == sigIdx.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        require(sigV.length == sigR.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        require(sigV.length == sigS.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        for (uint i = 0; i < sigIdx.length; i++) {\n            if ((i > 0 && sigIdx[i] <= sigIdx[i-1]) || sigIdx[i] >= signers.length) {\n                return false;\n            }\n            signers[i] = signers[sigIdx[i]];\n        }\n\n        // Get double block hash from instRoot and other data\n        bytes32 blk = keccak256(abi.encodePacked(keccak256(abi.encodePacked(blkData, instRoot))));\n\n        // Check if enough validators signed this block\n        if (sigIdx.length <= signers.length * 2 / 3) {\n            return false;\n        }\n\n        // Check that signature is correct\n        require(verifySig(signers, blk, sigV, sigR, sigS), errorToString(Errors.SIGNATURE_INVALID));\n\n        // Check that inst is in block\n        require(instructionInMerkleTree(\n            instHash,\n            instRoot,\n            instPath,\n            instPathIsLeft\n        ), errorToString(Errors.MERKLE_PROOF_INVALID));\n\n        return true;\n    }\n\n    /**\n     * @dev Finds the beacon committee in charge of signing a block height\n     * @notice This functions does a binary search of all committees (since genesis block)\n     * @param blkHeight: to search for\n     * @return committee: address of the committee members\n     * @return id: index of the committee\n     */\n    function findBeaconCommitteeFromHeight(uint blkHeight) public view returns (address[] memory, uint) {\n        uint l = 0;\n        uint r = beaconCommittees.length;\n        require(r > 0, errorToString(Errors.UNEXPECTED_ERROR));\n        r = r - 1;\n        while (l != r) {\n            uint m = (l + r + 1) / 2;\n            if (beaconCommittees[m].startBlock <= blkHeight) {\n                l = m;\n            } else {\n                r = m - 1;\n            }\n        }\n        return (beaconCommittees[l].pubkeys, l);\n    }\n\n    /**\n     * @dev Finds the bridge committee in charge of signing a block height\n     * @notice The same as findBeaconCommitteeFromHeight but for bridge chain\n     */\n    function findBridgeCommitteeFromHeight(uint blkHeight) public view returns (address[] memory, uint) {\n        uint l = 0;\n        uint r = bridgeCommittees.length;\n        require(r > 0, errorToString(Errors.UNEXPECTED_ERROR));\n        r = r - 1;\n        while (l != r) {\n            uint m = (l + r + 1) / 2;\n            if (bridgeCommittees[m].startBlock <= blkHeight) {\n                l = m;\n            } else {\n                r = m - 1;\n            }\n        }\n        return (bridgeCommittees[l].pubkeys, l);\n    }\n\n    /**\n     * @dev Checks if a value is in a merkle tree\n     * @param leaf: the value to check\n     * @param root: of the merkle tree\n     * @param path: merkle path of the value to check\n     * @param left: whether each node on the path is the left or right child\n     * @return bool: whether the value is in the merkle tree\n     */\n    function instructionInMerkleTree(\n        bytes32 leaf,\n        bytes32 root,\n        bytes32[] memory path,\n        bool[] memory left\n    ) public pure returns (bool) {\n        require(left.length == path.length, errorToString(Errors.MERKLE_PROOF_INVALID));\n        bytes32 hash = leaf;\n        for (uint i = 0; i < path.length; i++) {\n            if (left[i]) {\n                hash = keccak256(abi.encodePacked(path[i], hash));\n            } else if (path[i] == 0x0) {\n                hash = keccak256(abi.encodePacked(hash, hash));\n            } else {\n                hash = keccak256(abi.encodePacked(hash, path[i]));\n            }\n        }\n        return hash == root;\n    }\n\n    /**\n     * @dev Extracts the metadata of a swap instruction\n     * @param inst: the full instruction, containing both metadata and body\n     * @param expectedMeta: required type of the instruction, 70 for swapping beacon and 71 for bridge\n     * @param expectedShard: required ID of the Incognito shard containing the instruction, must be 1\n     * @return height: the starting block that the committee is responsible for\n     * @return prevHeight: the starting block of the signing committee for this instruction\n     */\n    function extractMetaFromInstruction(bytes memory inst, uint8 expectedMeta, uint8 expectedShard) public pure returns (uint, uint) {\n        require(inst.length >= 0x62, errorToString(Errors.INSTRUCTION_INVALID)); // 0x02 bytes for meta and shard, 0x20 each for height and numVals\n        uint8 meta = uint8(inst[0]);\n        uint8 shard = uint8(inst[1]);\n        uint height;\n        uint prevHeight;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            prevHeight := mload(add(inst, 0x22)) // [2:34]\n            height := mload(add(inst, 0x42)) // [34:66]\n        }\n        require(meta == expectedMeta && shard == expectedShard, errorToString(Errors.INSTRUCTION_INVALID));\n        return (prevHeight, height);\n    }\n\n    /**\n     * @dev Extracts the committee (body) from a swap instruction\n     * @param inst: the full instruction, containing both metadata and body\n     * @return committee: address of the committee members\n     */\n    function extractCommitteeFromInstruction(bytes memory inst) public pure returns (address[] memory) {\n        uint numVals;\n        assembly {\n            numVals := mload(add(inst, 0x62))\n        }\n\n        require(numVals > 0, errorToString(Errors.INSTRUCTION_INVALID));\n        require(inst.length == 0x62 + numVals * 0x20, errorToString(Errors.INSTRUCTION_INVALID));\n        address[] memory addr = new address[](numVals);\n        address tmp;\n        for (uint i = 0; i < numVals; i++) {\n            assembly {\n                // skip first 0x20 bytes (stored length of inst)\n                // also, skip the next 0x62 bytes (stored metadata)\n                tmp := mload(add(add(inst, 0x82), mul(i, 0x20))) // 67+i*32\n            }\n            addr[i] = tmp;\n        }\n        return addr;\n    }\n\n    /**\n     * @dev Verifies that the signatures for a message are correct\n     * @param msgHash: the message to be verify\n     * @param v: part of the signatures\n     * @param r: part of the signatures\n     * @param s: part of the signatures\n     * @return bool: whether all signatures are correct\n     */\n    function verifySig(\n        address[] memory committee,\n        bytes32 msgHash,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) public pure returns (bool) {\n        require(v.length == r.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        require(v.length == s.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        for (uint i = 0; i < v.length; i++){\n            address recoveredAddress = ecrecover(msgHash, v[i], r[i], s[i]);\n            if (recoveredAddress == address(0x0) || recoveredAddress != committee[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n}\n"
    },
    "contracts/pause.sol": {
      "content": "pragma solidity ^0.6.12;\n\ncontract AdminPausable {\n    address public admin;\n    address public successor;\n    bool public paused;\n    uint public expire;\n\n    constructor(address _admin) public {\n        admin = _admin;\n        paused = false;\n        expire = block.timestamp + 365 * 1 days;\n    }\n\n    event Paused(address pauser);\n    event Unpaused(address pauser);\n    event Extend(uint ndays);\n    event Claim(address claimer);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"not admin\");\n        _;\n    }\n\n    modifier isPaused() {\n        require(paused, \"not paused right now\");\n        _;\n    }\n\n    modifier isNotPaused() {\n        require(!paused, \"paused right now\");\n        _;\n    }\n\n    modifier isNotExpired() {\n        require(block.timestamp < expire, \"expired\");\n        _;\n    }\n\n    function retire(address _successor) public onlyAdmin isNotExpired {\n        successor = _successor;\n    }\n\n    function claim() public isNotExpired {\n        require(msg.sender == successor, \"unauthorized\");\n        admin = successor;\n        emit Claim(admin);\n    }\n\n    function extend(uint n) public onlyAdmin isNotExpired {\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n        expire = expire + n * 1 days;\n        emit Extend(n);\n    }\n\n    function pause() public onlyAdmin isNotPaused isNotExpired {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyAdmin isPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}